@using HotfixMods.Infrastructure.Razor.Pages.SpellVisualKitTabs
@using HotfixMods.Core.Enums.Db2;

@inject SpellVisualKitService Service
@inherits HotfixPageBase

@*
    This page turned out a little bit messy. If the code is unreadable at a later time, consider replacing the custom foreach code with simple if-conditions to load the effects instead.
*@

@if (null == PageTab.Dto)
{
    <TabContentView Data="new List<DashboardModel>()" New_Callback="NewAsync_Click<SpellVisualKitSearch_Dialog>" Title="Spell Visual Kits">
    </TabContentView>
}
else
{
    <TabContentEditHeader @ref="tabContentEditHeaderRef" IsUpdate="false" Title="Spell Visual Kits" ValueCompare_Callback="@(async () => ValueCompareAsync_Click<SpellVisualKitSearch_Dialog>())">
        <ChildContent>
            <MudTabPanel Class="custom-mud-tabs">
                <TabContent>
                    <TabTitle_Element Line1="HotfixMods" Line2="Entity" />
                </TabContent>
                <ChildContent>
                    <TabContentEditBody T="object">
                        <SpellVisualKitEntity_Tab Value="((SpellVisualKitDto)PageTab.Dto).Entity" />
                    </TabContentEditBody>
                </ChildContent>
            </MudTabPanel>
            <MudTabPanel Class="custom-mud-tabs">
                <TabContent>
                    <TabTitle_Element Line1="Spell" Line2="Visual Kit" />
                </TabContent>
                <ChildContent>
                    <TabContentEditBody T="object">
                        <SpellVisualKit_Tab Value="((SpellVisualKitDto)PageTab.Dto).SpellVisualKit" />
                    </TabContentEditBody>
                </ChildContent>
            </MudTabPanel>
            <MudTabPanel Class="custom-mud-tabs">
                <TabContent>
                    <TabTitle_Element Line1="Spell Visual" Line2="Kit Effect" />
                </TabContent>
                <ChildContent>
                    <TabContentEditBody T="SpellVisualKitDto.EffectGroup" Instances="((SpellVisualKitDto?)PageTab.Dto).EffectGroups" CurrentInstanceChanged="CurrentInstanceChanged" CurrentInstance="currentEffectInstance">
                        @if (((SpellVisualKitDto?)PageTab.Dto).EffectGroups.Any())
                        {
                            foreach ((var effect, int index) in ((SpellVisualKitDto?)PageTab.Dto).EffectGroups.WithIndex())
                            {
                                <SpellVisualKitEffect_Tab EffectDisabled="@(displayEffectTab)" EffectTypeChanged="CurrentEffectTypeChanged" Value="effect.SpellVisualKitEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > index ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellVisualKitEffect : null)" />
                            }
                        }
                        else
                        {
                            <TabContentNoData Text="There are no Item Effects yet." />
                        }
                    </TabContentEditBody>
                </ChildContent>
            </MudTabPanel>

            @if (displayEffectTab || firstRender)
            {
                int currentPage = -1;
                int amountOfPages = 1;
                EventCallback<int> currentPageChanged = default;

                if(currentEffectType == SpellVisualEffectEffectType.DISSOLVE_EFFECT)
                {
                    currentPage = currentDissolveEffectPage;
                    amountOfPages = 2;

                }

                <MudTabPanel Class="custom-mud-tabs">
                    <TabContent>
                        <TabTitle_Element @ref="tabTitleRef" />
                    </TabContent>
                    <ChildContent>
                        <TabContentEditBody T="SpellVisualKitDto.EffectGroup" Instances="((SpellVisualKitDto?)PageTab.Dto).EffectGroups" CurrentInstanceChanged="CurrentInstanceChanged" CurrentInstance="currentEffectInstance" CurrentPage="currentPage" AmountOfPages="amountOfPages" CurrentPageChanged="CurentDissolveEffectPageChanged">
                            @if (((SpellVisualKitDto?)PageTab.Dto).EffectGroups.Any())
                            {
                                foreach ((var effect, int index) in ((SpellVisualKitDto?)PageTab.Dto).EffectGroups.WithIndex())
                                {
                                    switch (currentEffectType)
                                    {
                                        case SpellVisualEffectEffectType.SPELL_PROCEDURAL_EFFECT:
                                            {
                                                <SpellProceduralEffect_Tab Value="effect.SpellProceduralEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellProceduralEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.SPELL_VISUAL_KIT_MODEL_ATTACH:
                                            {
                                                <SpellVisualKitModelAttach_Tab Value="effect.SpellVisualKitModelAttach" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellVisualKitModelAttach : null)" />
                                                break;
                                            }

                                        case SpellVisualEffectEffectType.SPELL_VISUAL_ANIM:
                                            {
                                                <SpellVisualAnim_Tab Value="effect.SpellVisualAnim" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellVisualAnim : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.SHADOWY_EFFECT:
                                            {
                                                <ShadowyEffect_Tab Value="effect.ShadowyEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].ShadowyEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.SPELL_EFFECT_EMISSION:
                                            {
                                                <SpellEffectEmission_Tab Value="effect.SpellEffectEmission" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellEffectEmission : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.OUTLINE_EFFECT:
                                            {
                                                <OutlineEffect_Tab Value="effect.OutlineEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].OutlineEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.DISSOLVE_EFFECT:
                                            {
                                                <DissolveEffect_Tab Value="effect.DissolveEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].DissolveEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.EDGE_GLOW_EFFECT:
                                            {
                                                <EdgeGlowEffect_Tab Value="effect.EdgeGlowEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].EdgeGlowEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.BEAM_EFFECT:
                                            {
                                                <BeamEffect_Tab Value="effect.BeamEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].BeamEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.CLONE_EFFECT:
                                            {
                                                <CloneEffect_Tab Value="effect.CloneEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].CloneEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.GRADIENT_EFFECT:
                                            {
                                                <GradientEffect_Tab Value="effect.GradientEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].GradientEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.BARRAGE_EFFECT:
                                            {
                                                <BarrageEffect_Tab Value="effect.BarrageEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].BarrageEffect : null)" />
                                                break;
                                            }
                                        case SpellVisualEffectEffectType.ROPE_EFFECT:
                                            {
                                                <RopeEffect_Tab Value="effect.RopeEffect" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].RopeEffect : null)" />
                                                break;
                                            }
                                        default:
                                            {
                                                <TabContentNoData Text="Content not available." />
                                                break;
                                            }
                                    }
                                }
                            }
                            else
                            {
                                <TabContentNoData Text="There are no Spell Visual Effects yet." />

                                displayEffectTab = false;
                            }
                        </TabContentEditBody>


                    </ChildContent>
                </MudTabPanel>
            }
            @if (displaySpellVisualEffectNameTab || firstRender)
            {
                <MudTabPanel Class="custom-mud-tabs">
                    <TabContent>
                        <TabTitle_Element Line1="Spell Visual" Line2="Effect Name" />
                    </TabContent>
                    <ChildContent>
                        <TabContentEditBody T="SpellVisualKitDto.EffectGroup" Instances="((SpellVisualKitDto?)PageTab.Dto).EffectGroups" CurrentInstanceChanged="CurrentInstanceChanged" CurrentInstance="currentEffectInstance">

                            @if (((SpellVisualKitDto?)PageTab.Dto).EffectGroups.Any())
                            {
                                foreach ((var effect, int index) in ((SpellVisualKitDto?)PageTab.Dto).EffectGroups.WithIndex())
                                {
                                    <SpellVisualEffectName_Tab Value="effect.SpellVisualEffectName" ValueCompare="@(PageTab.DtoCompare != null && ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups.Count > currentEffectInstance ? ((SpellVisualKitDto?)PageTab.DtoCompare)?.EffectGroups[index].SpellVisualEffectName : null)" />
                                }
                            }
                            else
                            {
                                <TabContentNoData Text="There are no Spell Visual Effects yet." />
                            }
                        </TabContentEditBody>

                    </ChildContent>
                </MudTabPanel>
            }
        </ChildContent>
    </TabContentEditHeader>
}

@code {
    TabContentEditHeader? tabContentEditHeaderRef;

    int currentEffectInstance = 1;
    int currentDissolveEffectPage = 1;
    SpellVisualEffectEffectType? currentEffectType = null;
    bool displayEffectTab = false;
    bool displaySpellVisualEffectNameTab = false;
    TabTitle_Element? tabTitleRef;
    bool firstRender = true;

    protected override void OnAfterRender(bool firstRender)
    {
        if(firstRender)
            this.firstRender = false;

        base.OnAfterRender(firstRender);
    }

    async void CurrentInstanceChanged(int newCurrentInstance)
    {
        // I do not understand this part, but when adding the very first instance, the newCurrentInstance is 2, anod not 1 as expected.
        // It will correct itself somehow on a followup call, but for now, add this condition to stop the exception.
        // The error is probably due to a misconception of the specific MudBlazor component usage.

        if (((SpellVisualKitDto?)PageTab.Dto).EffectGroups.Count >= newCurrentInstance)
        {
            currentEffectInstance = newCurrentInstance;
            int newCurrentEffectType = ((SpellVisualKitDto?)PageTab.Dto).EffectGroups[newCurrentInstance - 1].SpellVisualKitEffect.EffectType;
            await SetCurrentEffectType(newCurrentEffectType);
        }
    }

    async void CurrentEffectTypeChanged(int newCurrentEffectType)
    {
        await SetCurrentEffectType(newCurrentEffectType);
    }

    async Task SetCurrentEffectType(int newCurrentEffectType)
    {
        if (Enum.IsDefined(typeof(SpellVisualEffectEffectType), newCurrentEffectType))
        {
            currentEffectType = (SpellVisualEffectEffectType)newCurrentEffectType;
        }
        else
        {
            currentEffectType = null;
        }

        if (tabTitleRef != null)
        {
            displayEffectTab = true;
            displaySpellVisualEffectNameTab = false;
            switch (currentEffectType)
            {
                case SpellVisualEffectEffectType.SPELL_PROCEDURAL_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(SpellProceduralEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.SPELL_VISUAL_KIT_MODEL_ATTACH:
                    {
                        displaySpellVisualEffectNameTab = true;
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(SpellVisualKitModelAttach).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.SPELL_VISUAL_ANIM:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(SpellVisualAnim).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.SHADOWY_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(ShadowyEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.SPELL_EFFECT_EMISSION:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(SpellEffectEmission).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.OUTLINE_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(OutlineEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.DISSOLVE_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(DissolveEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.EDGE_GLOW_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(EdgeGlowEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.BEAM_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(BeamEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.CLONE_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(CloneEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.GRADIENT_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(GradientEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.BARRAGE_EFFECT:
                    {
                        displaySpellVisualEffectNameTab = true;
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(BarrageEffect).ToDisplayName()));
                        break;
                    }
                case SpellVisualEffectEffectType.ROPE_EFFECT:
                    {
                        await InvokeAsync(() => tabTitleRef.SetTitle(nameof(RopeEffect).ToDisplayName()));
                        break;
                    }
                default:
                    {
                        displayEffectTab = false;
                        await InvokeAsync(() => tabTitleRef.SetTitle("No effect")); // Placeholder value. Should not be visible
                        break;
                    }
            }
        }

        await InvokeAsync(() => this.StateHasChanged());
        await InvokeAsync(() => tabContentEditHeaderRef?.ReloadState());
    }

    void CurentDissolveEffectPageChanged(int newPage)
    {
        currentDissolveEffectPage = newPage;
    }
}