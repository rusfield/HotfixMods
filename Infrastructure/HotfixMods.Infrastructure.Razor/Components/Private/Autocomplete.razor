@typeparam T

@using HotfixMods.Infrastructure.Razor.Business


<MudAutocomplete @ref="mudAutocompleteRef" T="string" Value="@ShowValue()" Text="@ShowValue()" ValueChanged="InputValueChanged" Label="@Label" SelectValueOnTab="true" Variant="@Variant" SearchFunc="@Search" HelperText="@(ComponentHelper.GetHelperText<T>())" HelperTextOnFocus="true" MaxItems="null" ShowProgressIndicator="true" Adornment="Adornment" AdornmentIcon="@AdornmentIcon" OnAdornmentClick="OnAdornmentClick">
    <NoItemsTemplate>
        <MudList Clickable="true">
            <MudListItem OnClick="(async () => mudAutocompleteRef?.ToggleMenu())">
                @Value
            </MudListItem>
        </MudList>
    </NoItemsTemplate>
</MudAutocomplete>


@code {
    [Parameter]
    public string? Label { get; set; }

    [Parameter]
    public T? Value { get; set; }

    [Parameter]
    public Dictionary<T, string> Options { get; set; } = new();

    [Parameter]
    public EventCallback<T?> ValueChanged { get; set; }

    [Parameter]
    public Variant Variant { get; set; } = Variant.Outlined;

    [Parameter]
    public string AdornmentIcon { get; set; }

    [Parameter]
    public EventCallback OnAdornmentClick { get; set; }

    [Parameter]
    public Adornment Adornment { get; set; }

    string? _inputValue;
    MudAutocomplete<string>? mudAutocompleteRef;

    async Task InputValueChanged(string input)
    {
        string type = (Nullable.GetUnderlyingType(typeof(T)) ?? typeof(T)).ToString();
        var listItem = Options.Where(x => x.Value.Equals(input, StringComparison.InvariantCultureIgnoreCase) || x.Key.ToString() == input);
        var value = listItem.Count() > 0 ? listItem.First().Key.ToString() : input;

        if ("System.SByte" == type && sbyte.TryParse(value, out var sbyteValue))
        {
            Value = (T)Convert.ChangeType(sbyteValue, typeof(sbyte));
        }
        if ("System.Byte" == type && byte.TryParse(value, out var byteValue))
        {
            Value = (T)Convert.ChangeType(byteValue, typeof(byte));
        }
        if ("System.Int16" == type && short.TryParse(value, out var shortValue))
        {
            Value = (T)Convert.ChangeType(shortValue, typeof(short));
        }
        if ("System.UInt16" == type && ushort.TryParse(value, out var ushortValue))
        {
            Value = (T)Convert.ChangeType(ushortValue, typeof(ushort));
        }
        else if ("System.Int32" == type && int.TryParse(value, out var intValue))
        {
            Value = (T)Convert.ChangeType(intValue, typeof(int));
        }
        else if ("System.UInt32" == type && uint.TryParse(value, out var uintValue))
        {
            Value = (T)Convert.ChangeType(uintValue, typeof(uint));
        }
        else if ("System.Int64" == type && long.TryParse(value, out var longValue))
        {
            Value = (T)Convert.ChangeType(longValue, typeof(long));
        }
        else if ("System.UInt64" == type && ulong.TryParse(value, out var ulongValue))
        {
            Value = (T)Convert.ChangeType(ulongValue, typeof(ulong));
        }
        else if ("System.Decimal" == type && decimal.TryParse(value, out var decimalValue))
        {
            Value = (T)Convert.ChangeType(decimalValue, typeof(decimal));
        }
        else if ("System.String" == type && value != null)
        {
            Value = (T)Convert.ChangeType(value, typeof(string));
        }
        else
        {
            Value = default(T);
        }

        await ValueChanged.InvokeAsync(Value);
    }

    async Task<IEnumerable<string>> Search(string value)
    {
        if (string.IsNullOrEmpty(value))
            return Options.Select(o => o.Value);

        var options = Options.Where(x => x.Value.Contains(value, StringComparison.InvariantCultureIgnoreCase) || x.Key.ToString() == value).Select(o => o.Value).ToList();
        if (!options.Any(o => o.Equals(value, StringComparison.InvariantCultureIgnoreCase)))
            options.Add(value);
        return options;
    }

    string? ShowValue()
    {
        if (null == Value)
            return "";
        var option = Options.Where(x => x.Value.Contains(Value.ToString() ?? "", StringComparison.InvariantCultureIgnoreCase) || x.Key.ToString() == Value.ToString()).Select(x => x.Value).FirstOrDefault();
        return (option ?? Value.ToString()) ?? "Not found";
    }
}
